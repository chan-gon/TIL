# 값 타입

JPA는 데이터 타입을 최상위 레벨에서 두 가지로 구분합니다.

- 엔티티 타입
    - 엔티티로 정의하는 객체
    - 데이터가 변해도 식별자로 지속해서 추적 가능
    - ex) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능

- 값 타입
    - int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
    - 식별자가 없고 값만 있으므로 변경시 추적 불가
    - ex) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체

## 값 타입 분류

- 기본값 타입
    - 자바 기본 타입(int, double)
    - 래퍼 클래스(Integer, Long)
    - String

- 임베디드 타입(embedded type, 복합 값 타입)

- 컬렉션 값 타입(collection value type)

## 기본값 타입

기본값 타입은 String name, int age와 같은 형태를 가집니다.

- 생명주기를 엔티티에 의존
    - ex) 회원을 삭제하면 이름, 나이 필드도 함꼐 삭제

- 값 타입은 공유하면 안된다
    - ex) 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안된다

*NOTE*

자바의 기본 타입은 절대 공유되지 않습니다.  
- int, double같은 기본 타입(primitive type)은 절대 공유되지 않습니다.  

- 기본 타입은 항상 값을 복사합니다.  

- Integer같은 래퍼 클래스나 String같은 특수한 클래스는 공유 가능한 객체이지만 변경되지 않습니다.

## 임베디드 타입

내장 타입 또는 임베디드 타입이라고 불린다.  
임베디드 타입을 사용하면 테이블 형태는 유지하면서 객체지향스러운 구현을 가능합니다.

- 새로운 값 타입을 직접 정의할 수 있다.

- JPA는 임베디드 타입(Embedded Type) 이라고 한다.

- 주로 기본 값 타입을 모아서 만들었기 때문에 복합 값 타입이라고도 한다.

- int, String과 같은 값 타입이다.(엔티티 타입 아님)

## 임베디드 타입 장점

- 재사용 가능

- 높은 응집도

- Period.isWork()처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음

- 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함

## 임베디드 타입과 테이블 매핑

![임베디드타입](../images/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C%ED%83%80%EC%9E%85-1.png)

- 임베디드 타입은 엔티티의 값일 뿐이다.

- 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.

- 객체와 테이블을 아주 세밀하게(fine-grained) 매핑하는 것이 가능하다.

- 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다.

## 임베디드 타입 예제

위 이미지와 같이 Member 엔티티 클래스를 작성합니다.

```
@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    // 기간
    LocalDateTime startDate;
    LocalDateTime endDate;

    // 주소
    String city;
    String street;
    String zipcode;
}
```

선언된 컬럼을 보면 기간, 주소로 해당 필드를 묶어놓으면 중복 작업을 피할 수 있고 다른 곳에서 재사용하기 좋을 것 같습니다.  
그래서 Period, Address 클래스를 생성한 다음 각 필드를 그곳에 넣습니다.

![임베디드타입](../images/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C%ED%83%80%EC%9E%85-2.png)

중요한 것은 임베디드 타입을 사용한다는 어노테이션을 사용해야 합니다.  

- @Embeddable: 값 타입을 정의하는 곳에 표시

- @Embedded: 값 타입을 사용하는 곳에 표시

- 기본 생성자는 필수!

```
@Embeddable
public class Period {
    private LocalDateTime startDate;
    private LocalDateTime endDate;

    public Period() {

    }
}

@Embeddable
public class Address {
    private String city;
    private String street;
    private String zipcode;

    public Address() {

    }
}

@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    @Embedded
    private Period period;

    @Embedded
    private Address address;
```

이렇게 임베디드 타입을 사용해서 테이블 매핑을 구현하면 이전에 필요한 컬럼을 하나의 클래스에 모두 몰아넣은 형태와 동일하게 동작합니다.  
그리고 모델링이 깔끔하게 됩니다. Member 테이블에는 아이디, 이름, 생성일, 수정일, 주소... 이렇게 설명하지 않고 **아이디, 이름, 기간, 주소** 이렇게 깔끔하게 떨어집니다.

## 임베디드 타입 - @AttributeOverride

만약 하나의 엔티티에 같은 값 타입을 사용해야 한다면, 그냥 같은 타입을 사용하면 될 것 같지만, 사용하면 에러가 발생합니다.

Member 엔티티에 아래와 같이 구현합니다. Address 속성을 두 개 사용하고 있습니다.

```
@Embedded
private Address address;

@Embedded
private Address homeAddress;
```

실행하면 관련 에러가 발생합니다. 메시지를 보니 엔티티에 같은 컬럼이 중복 사용되었다고 하네요.

```
Caused by: org.hibernate.MappingException: Repeated column in mapping for entity: hellojpa.Member column: city (should be mapped with insert="false" update="false")
```

이 때 사용하는 것이 @AttributeOverride 입니다.  
사용법은 다소 번거롭습니다.

```
@Embedded
private Address address;

@Embedded
@AttributeOverrides({@AttributeOverride(name = "city",
        column = @Column(name = "home_city")),
        @AttributeOverride(name = "street",
        column = @Column(name = "home_street")),
        @AttributeOverride(name = "zipcode",
        column = @Column(name = "home_zipcode"))
})
private Address homeAddress;
```

다시 코드를 실행하면 정상 실행되고, 테이블을 확인하면 오버라이딩된 컬럼이 추가된 것을 확인할 수 있습니다.

![임베디드타입](../images/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C%ED%83%80%EC%9E%85-3.png)

## 임베디드 타입의 값이 null이면 매핑한 컬럼 값은 모두 null이 된다는 것에 주의!

```
@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    @Embedded
    private Period period = null;

    @Embedded
    private Address address = null;
```

임베디드 타입 Period, Address의 값을 null로 지정하면 해당 클래스의 컬럼값은 모두 null이 됩니다.

## 값 타입과 분변 객체

값 타입은 복잡한 객체 세상을 조금이라도 단순화하려고 만든 개념입니다. 따라서 값 타입을 단순하고 안전하게 다룰 수 있어야 합니다.

## 값 타입 공유 참조

- 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험하다. 부작용이 발생한다.

임베디드 타입 값인 Address를 member1, member2에서 공유합니다. 그리고 member1 객체만 Address의 city값을 변경하려고 합니다. 그런데 member1, member2 모두에게 적용되었습니다.
이 상황에서는 어느 객체 하나를 콕 집어서 적용시키는 것은 불가능합니다.

```
Address address = new Address("Daegu", "Suseong", "1234");

Member member1 = new Member();
member1.setUsername("Kim");
member1.setAddress(address);
entityManager.persist(member1);

Member member2 = new Member();
member2.setUsername("Park");
member2.setAddress(address);
entityManager.persist(member2);

member1.getAddress().setCity("Changwon");
```

![공유참조](../images/%EA%B3%B5%EC%9C%A0%EC%B0%B8%EC%A1%B0-1.png)

## 값 타입 복사

- 값 타입의 실제 인스턴스인 값을 공유하는 것을 위험하다.

-  대신 값(인스턴스)을 복사해서 사용해야 한다.

첫 번째로 생성한 Address 인스턴스를 복사해서 사용합니다.

```
Address address = new Address("Daegu", "Suseong", "1234");

Member member1 = new Member();
member1.setUsername("Kim");
member1.setAddress(address);
entityManager.persist(member1);

Address address2 = new Address(address.getCity(), address.getStreet(), address.getZipcode());

Member member2 = new Member();
member2.setUsername("Park");
member2.setAddress(address2);
entityManager.persist(member2);

member1.getAddress().setCity("Gangwon");
```

![공유참조](../images/%EA%B3%B5%EC%9C%A0%EC%B0%B8%EC%A1%B0-2.png)

## 객체 타입의 한계

- 항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다.

- 문제는 임베디드 타입처럼 **직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입**이다.

- 자바 기본 타입에 값을 대입하면 값을 복사한다.

- **객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다.**

- **객체의 공유 참조는 피할 수 없다.**

## 불변 객체

- 객체 타입을 수정할 수 없게 만들면 **부작용을 원천 차단할 수 있다.**

- **값 타입은 불변 객체(immutable object)로 설계해야 한다.**
    - 불변 객체란 생성 시점 이후 절대 값을 변경할 수 없는 객체

- 생성자로만 값을 설정하고 수정자(Setter)를 만들지 않으면 된다

객체지향 개발 시 참고하는 기본 개발 원칙을 보는 것 같습니다.

# 참고 
- https://www.inflearn.com/course/ORM-JPA-Basic/dashboard