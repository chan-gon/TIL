# 기본 키 매핑

기본 키 매핑 어노테이션

- @Id

- @GeneratedValue

기본 키 매핑 방법

- 직접 할당: @Id만 사용.

- 자동 생성: @GeneratedValue 사용.

직접 할당이 아닌 값을 생성해서 사용하고 싶다면 @GeneratedValue 어노테이션의 strategy 속성을 추가하면 됩니다.  
생성 전략은 네 가지가 있습니다.

![기본 키 자동 생성](../images/%EA%B8%B0%EB%B3%B8%ED%82%A4%EB%A7%A4%ED%95%91-1.png)

### 자동 생성 전략 - IDENTITY

- 기본 키 생성을 데이터베이스에 위임합니다. 

- 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용합니다.
    - ex) MySQL의 AUTO_INCREMENT

- JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행합니다.

- AUTO_INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID값을 알 수 있습니다.

- IDENTITY 전략은 EntityManager.persist() 시점에 즉시 INSERT SQL을 실행하고 DB에서 식별자를 조회합니다.

엔티티 설정

```
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

실행 결과(H2 데이터베이스)

```
create table Member (
    id bigint generated by default as identity,
    name varchar(255),
    primary key (id)
)
```

데이터베이스 방언을 MySQL로 변경한 후 실행하면 쿼리문이 다음과 같이 변경됩니다.

```
create table Member (
    id bigint not null auto_increment,
    name varchar(255),
    primary key (id)
) engine=MyISAM
```

이렇게 설정해서 테이블이 생성되면 INSERT SQL이 실행될 때마다 PK값이 자동으로 증가하는 것을 확인할 수 있습니다.

```
public class JpaMain {

    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager entityManager = emf.createEntityManager();

        EntityTransaction tx = entityManager.getTransaction();

        tx.begin();

        try {
            Member member = new Member();
            member.setName("Kim");
            entityManager.persist(member);

            // 트랜잭션 커밋 시점에 쿼리문 실행됨
            tx.commit();
        } catch (Exception e) {
            tx.rollback();
        } finally {
            entityManager.close();
        }
        emf.close();

    }
}
```

위 코드를 두 번 실행한 결과는 아래와 같습니다.  
PK 컬럼으로 매핑된 id가 자동으로 증가하는 것을 확인할 수 있습니다.

![기본 키 매핑](../images/%EA%B8%B0%EB%B3%B8%ED%82%A4%EB%A7%A4%ED%95%91-2.png)

### *NOTE*

IDENTITY 생성 전략은 PK값을 설정하지 않고(null) INSERT SQL을 던지면 그 때 PK의 값을 세팅합니다. 즉 쿼리문 실행 이후에 PK값을 알 수 있습니다.  
일반적인 JPA 동작 방식은 영속성 컨텍스트에 엔티티 정보를 가지고 있다가 요청이 들어오면 DB에 쿼리문을 날리는 방식으로 동작합니다. 그런데 IDENTITY 생성 전략에 따르면 쿼리문 실행 이후 PK가 생성됩니다. 논리적인 오류가 발생합니다. 영속성 컨텍스트에서 객체가 관리되려면 무조건 PK값이 있어야 하는데 IDENTITY 생성 전략은 그렇게 동작하지 않기 때문입니다.  

그래서 IDENTITY 전략에서만 예외적으로 EntityManager.persist()가 호출되는 시점에서 바로 DB에 INSERT 쿼리문을 날립니다.(일반적으로 트랜잭션 커밋 시점에 쿼리문을 날립니다. 이미 PK값을 알고 있기 때문에 그렇게 동작할 수 있습니다.) persist()가 호출되는 즉시 INSERT 쿼리를 통해 DB에서 식별자를 조회해서 영속성 컨텍스트의 1차 캐시에 값을 넣습니다.

### 자동 생성 전략 - SEQUENCE

- 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트 입니다.

- 오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용합니다.

생성 전략을 SEQUENCE로 변경 후 INSERT SQL을 실행해봅니다.

```
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE)
private Long id;
```

실행 결과는 다음과 같습니다.(H2 데이터베이스 기준)  
먼저 시퀀스를 생성한 후 INSERT SQL을 작성할 때 시퀀스를 호출해서 값을 가져오고, 그 값을 PK에 넣는 것을 확인할 수 있습니다.

```
Hibernate: create sequence hibernate_sequence start with 1 increment by 1
Hibernate: 
    
    create table Member (
       id bigint not null,
        name varchar(255),
        primary key (id)
    )

Hibernate: 
    call next value for hibernate_sequence
Hibernate: 
    /* insert hellojpa.Member
        */ insert 
        into
            Member
            (name, id) 
        values
            (?, ?)
```

@GeneratedValue(strategy = GenerationType.SEQUENCE)만 작성하면 Hibernate가 만드는 기본 시퀀스 hibernate_sequence를 만들어서 사용합니다.  
만약 테이블마다 시퀀스 오브젝트를 따로 관리하고 싶다면 @SequenceGenerator의 sequenceName 속성을 통해 커스터마이징 할 수 있습니다.

먼저 클래스 레벨에서 @SequenceGenerator 어노테이션 및 속성을 추가한 후 @GeneratedValue의 generator 속성에 @SequenceGenerator에서 설정한 시퀀스 이름을 삽입하면 됩니다.

```
@Entity
@SequenceGenerator(
        name = "MEMBER_SEQUENCE",
        sequenceName = "MEMBER_SEQ",
        initialValue = 1,
        allocationSize = 1)
public class Member {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "MEMBER_SEQUENCE")
    private Long id;
    @Column(name = "name")
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

위 설정 내용을 토대로 다시 코드를 실행합니다.  
@SequenceGenerator에서 설정한 내용대로 등록한 시퀀스가 생성 및 작동되는 것을 확인할 수 있습니다.

```
Hibernate: create sequence MEMBER_SEQ start with 1 increment by 1
Hibernate: 
    
    create table Member (
       id bigint not null,
        name varchar(255),
        primary key (id)
    )

Hibernate: 
    call next value for MEMBER_SEQ
Hibernate: 
    /* insert hellojpa.Member
        */ insert 
        into
            Member
            (name, id) 
        values
            (?, ?)
```

@SequenceGenerator 속성

|속성|설명|기본값|
|---|---|---|
|name|식별자 생성기 이름|필수|
|sequenceName|데이터베이스에 등록되어 있는 시퀀스 이름|hibernate_sequence|
|initialValue|DDL 생성 시에만 사용됨. 시퀀스 DDL을 생성할 때 처음 1 시작하는 수를 지정한다.|1|
|allocationSize|시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용된다). 데이터베이스 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정해야 한다.|50|
|catalog, schema|데이터베이스 catalog, schema 이름||

### *NOTE*



### 자동 생성 전략 - TABLE

- 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략

- @TableGenerator가 필요

- 모든 데이터베이스 적용 가능하지만, 최적화 되지 않은 테이블을 직접 사용하기 때문에 성능상의 이슈가 있음. 운영 서버에서 사용하기에 적합하지 않다.

```
@Entity
@TableGenerator(
        name = "MEMBER_SEQUENCE",
        table = "MY_SEQUENCES",
        pkColumnValue = "MEMBER_SEQ",
        allocationSize = 1)
public class Member {

    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "MEMBER_SEQUENCE")
    private Long id;
    @Column(name = "name")
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

실행 결과 로그를 보면 시퀀스 테이블을 생성하는 것을 확인할 수 있습니다. 생성된 시퀀스 테이블을 통해 시퀀스가 동작합니다.

```
Hibernate: 
    
    create table Member (
       id bigint not null,
        name varchar(255),
        primary key (id)
    )
Hibernate: 
    
    create table MY_SEQUENCES (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
```

@TableGenerator 속성 입니다.

![기본키매핑](../images/%EA%B8%B0%EB%B3%B8%ED%82%A4%EB%A7%A4%ED%95%91-3.png)

### 자동 생성 전략 - AUTO

- 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략을 자동으로 선택합니다.

### 권장하는 식별자 전략

- 기본 키는 null이 아니고, 유일하고, 변하면 안됩니다. 이 조건을 만족하는 자연키(natural key / 주민번호, 지역번호 등 비즈니스와 관련된 키)는 찾기 어렵습니다. 

- 그래서 비즈니스와 연관성이 없는 대리키(대체키) 사용을 추천합니다.

- PK로 주민번호를 사용하고 있는데 정책 변화로 주민번호 사용이 금지된 상황이 발생했다. 이 경우 해당 테이블 뿐만이 아니라 PK를 FK로 JOIN하고 있는 다른 테이블에도 문제가 발생한다. 이 경우 주빈번호를 FK로 참조하고 있는 모든 테이블을 마이그레이션해야 하는 문제가 발생하기 때문에 자연키보단 대체키 사용을 추천한다.

- 권장 포맷은 **Long형(큰 범위의 수를 포용하기 위해서) + 대체키 + 키 생성전략**의 조합을 사용한 것입니다.

# 참고
* [자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic/dashboard)
* [Heee's Development Blog](https://gmlwjd9405.github.io/2019/08/12/primary-key-mapping.html)