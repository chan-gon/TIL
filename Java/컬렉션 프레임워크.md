# 컬렉션 프레임워크

자바 컬렉션은 객체를 수집해서 저장하는 역할을 한다. 프레임워크란 사용 방법을 미리 정해 놓은 라이브러리를 말한다. 자바 컬렉션 프레임워크는 몇 가지 인터페이스를 통해 다양한 컬렉션 클래스를 이용할 수 있도록 한다. 주요 인터페이스는 List, Set, Map이 있다. 

![자바 컬렉션 프레임워크](./image/java_chapter15_1.png)

## List 컬렉션

[List 컬렉션](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)은 객체를 일렬로 늘어놓은 구조를 가지고 있다. 객체를 인덱스(index)로 관리하기 때문에 객체를 저장하면 자동으로 인덱스가 부여되고, 인덱스로 객체를 검색/삭제할 수 있는 기능을 제공한다. List 컬렉션은 객체 자체를 저장하는 것이 아니라 객체의 번지를 참조한다. 동일한 객체를 중복 저장할 수 있는데, 이 경우 동일한 번지가 참조된다. null도 저장 가능하다. 이 경우 해당 인덱스는 객체를 참조하지 않는다.

![List 컬렉션](./image/java_chapter15_2.png)

List 컬렉션에는 ArrayList, Vector, LinkedList 등이 있다. 아래 표는 List 컬렉션에서 공통적으로 사용 가능한 List 인터페이스의 메소드이다. 인덱스로 객체를 관리하기 때문에 인덱스를 매개값으로 갖는 메소드가 많다.

![List 컬렉션](./image/java_chapter15_3.png)

리턴 타입으로 E라는 타입 파라미터가 있는 경우가 있는데, 이것은 List 인터페이스가 제네릭 타입이기 때문이다. 구체적인 타입은 구현 객체를 생성할 때 결정된다. 

아래 코드는 List 컬렉션에 저장되는 구체적인 타입을 String으로 하고, 추가, 삽입, 삭제하는 모습이다.

<pre>
<code>
List<String> list = ...;
list.add("Park");
list.add(1,"Hong"); // 지정된 인덱스에 객체 삽입(1번 인덱스에 문자열 Hong을 삽입하겠다)
String str = list.get(1); // 인덱스로 특정 객체 찾아오기
list.remove(0); // 인덱스로 특정 객체 삭제
list.remove("Hong"); // 객체 삭제
</code>
</pre>

만약 전체 객체를 대상으로 하나씩 반복해서 저장된 객체를 얻고 싶다면 for문을 사용하면 된다.

<pre>
<code>
List<String> list = ...;
for(int i = 0; i<list.size(); i++) {
    String str = list.get(i); // i 인덱스에 저장된 String 객체 가져온다.
}
</code>
</pre>

인덱스가 필요 없다면 향상된 for문을 사용하는 것이 편리하다.
<pre>
<code>
for(String str : list) { ... } // String 객체를 하나씩 가져온다.
</code>
</pre>

### ArrayList

[ArrayList](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html)에 객체를 추가하면 객체가 인덱스로 관리된다. 일반 배열과 ArrayList는 인덱스로 객체를 관리한다는 점에서 유사하지만 차이점이 있다.

* 일반 배열: 생성 시 크기가 고정되고, 사용 중에 크기 변경이 불가능.
* ArrayList: 저장 용량(capacity)을 초과한 객체들이 들어오면 자동적으로 저장 용량이 늘어난다.
(As elements are added to an ArrayList, its capacity grows automatically.)

ArrayList를 생성하기 위해서는 저장할 객체 타입을 타입 파라미터로 표기하고 기본 생성자를 호출하면 된다. 예를 들어 String을 저장하는 ArrayList는 다음과 같이 생성할 수 있다.

<pre>
<code>
List<String> list = new ArrayList<String>();
</code>
</pre>

기본 생성자로 ArrayList 객체를 생성하면 내부에 10개의 객체를 저장할 수 있는 초기 용량(capacity)을 가지게 된다. 저장되는 객체 수가 늘어나면 용량이 자동으로 증가하고, 처음부터 용량을 크게 잡고 싶다면 용량의 크기를 매개값으로 받는 생성자를 이용하면 된다.

<pre>
<code>
// String 객체 30개를 저장할 수 있는 용량을 가지는 ArrayList 생성
List<String> list = new ArrayList<String>(30);
</code>
</pre>

ArrayList에 객체를 추가하면 인덱스 0부터 차례대로 저장된다. ArrayList에서 특정 인덱스의 객체를 제거하면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨진다. 마찬가지로 특정 인덱스에 객체를 삽입하면 해당 인덱스부터 마지막 인덱스까지 모두 1씩 밀려난다. 따라서 **빈번한 객체 삭제와 삽입이 일어나는 곳에서는 ArrayList를 사용하는 것이 바람직하지 않다. 이 경우 LinkedList를 사용하는 것이 좋다.** 인덱스 검색이나, 맨 마지막에 객체를 추가하는 경우라면 ArrayList가 더 좋은 성능을 발휘한다. 

아래 코드는 ArrayList에 String 객체를 추가, 검색, 삭제하는 모습이다.

<pre>
<code>
import java.util.*;

public class Main {
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();

        list.add("A1");
        list.add("A2");
        list.add("A3");

        // 저장된 총 객체 수 
        int size = list.size();
        System.out.println("size = " + size); // 3

        // 특정 인덱스의 객체 가져오기
        String value = list.get(1);
        System.out.println("value of an index 1 = " + value); // A2

        // 저장된 총 객체 수만큼 루핑
        for(int i = 0; i < list.size(); i++){
            String value = list.get(i);
            System.out.println(i + " : " + value);

            결과)
            0 : A1
            1 : A2
            2 : A3
        }
        
        // 특정 인덱스 객체 삭제
        list.remove(1);
        for(int i = 0; i < list.size(); i++){
            String value = list.get(i);
            System.out.println(i + " : " + value);

            결과)
            0 : A1
            1 : A3
        }

        // 특정 인덱스 객체 삭제   
        list.remove("A3");
        for(int i = 0; i < list.size(); i++){
            String value = list.get(i);
            System.out.println(i + " : " + value);

            결과)
            0 : A1
        }
    }
}
</code>
</pre>

ArrayList를 생성하고 런타임 시 필요에 의해 객체들을 추가하는 것이 일반적이지만, 고정된 객체들로 구성된 List를 생성할 때도 있다. 이 경우 Arrays.asList(T... a) 메소들르 사용하는 것이 간편하다.

<pre>
<code>
List<T> list = Arrays.asList(T... a);
</code>
</pre>

T 타입 파라미터에 맞게 asList()의 매개값을 순차적으로 입력하거나, T[] 배열을 매개값으로 주면 된다.
아래 코드는 고정된 String 객체를 요소로 갖는 ArrayList 객체를 생성한다.

<pre>
<code>
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("A1", "A2", "A3");
        for(String value : list) {
            System.out.println(value);
        }

        List<Integer> list2 = Arrays.asList(3, 2, 1);
        for(int value : list2) {
            System.out.println(value);
        }
    }
}

결과)
A1
A2
A3
3
2
1
</code>
</pre>

### Vector

[Vector](https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html)는 ArrayList와 동일한 내부 구조를 가지고 있다. Vector를 생성하기 위해서는 저장할 객체 타입을 타입 파라미터로 표기하고 기본 생성자를 호출한다.

<pre>
<code>
List<E> list = new Vector<E>();
</code>
</pre>

ArrayList와 다른 점은 Vector는 **동기화된(synchronized) 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드를 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다.** 그래서 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다. 이것을 스레드가 안전(Thread Safe)하다라고 말한다. 반대로 thread-safe한 동작이 필요하지 않은 경우, Vector 보다는 ArrayList의 사용이 권장된다.

아래 코드는 Vector를 이용해서 Board 객체를 추가, 삭제, 검색하는 예시이다.

<pre>
<code>
import java.util.*;

public class Main {
    public static void main(String[] args) {
        List<Board> list = new Vector<Board>();

        list.add(new Board("name1", "content1", "writer1"));
        list.add(new Board("name2", "content2", "writer2"));
        list.add(new Board("name3", "content3", "writer3"));


        list.remove(1); // 1번 인덱스 객체 삭제(뒤의 인덱스는 1씩 앞으로 당겨짐)

        for(int i = 0; i < list.size(); i++) {
            Board board = list.get(i);
            System.out.println(board.subject + " " + board.name + " " + board.writer);
        }
    }
}

// 게시물 정보 객체
public class Board {
    String subject;
    string name;
    String writer;

    public Board(String subject, Sting name, String writer) {
        this.subject = subject;
        this.name = name;
        this.writer = writer;
    }
}

결과)
name1 content1 writer1
name3 content3 writer3
</code>
</pre>

### LinkedList

[LinkedList](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html)는 List 구현 클래스이므로 ArrayList와 사용 방법은 동일하지만 내부 구조는 다르다. 

ArrayList는 내부 배열에 객체를 저장해서 인덱스로 관리하지만, LinkedList는 인접 참조를 링크해서 체인처럼 관리한다.

LinkedList에서 특정 인덱스의 객체를 제거하면 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다. 특정 인덱스에 객체를 삽입할 때에도 마찬가지다. ArrayList는 중간 인덱스의 객체를 제거하면 뒤의 객체는 인덱스가 1씩 앞으로 당겨진다. 그렇기 때문에 빈번한 객체 삭제와 삽입이 일어나는 곳에서는 ArrayList보다 LinkedList가 좋은 성능을 발휘한다. 

![LinkedList](./image/java_chapter15_4.png)

아래 이미지는 중간에 객체를 제거할 경우 앞뒤 링크의 수정이 일어나는 모습을 보여준다.

![LinkedList](./image/java_chapter15_5.png)

LinkiedList를 생성하려면 저장할 객체 타입을 타입 파라미터(E)에 표기하고 기본 생성자를 호출하면 된다. LinkedList가 처음 생성될 때에는 어떠한 링크도 만들어지지 않기 때문에 내부는 비어 있다고 보면 된다.

<pre>
<code>
List<E> list = new LinkedList<E>();
</code>
</pre>

아래 코드는 ArrayList와 LinkedList에 10000개의 객체를 삽입하는데 걸린 시간을 측정한다. 0번 인덱스에 String 객체를 10000번 추가하기 위해 List 인터페이스의 add(int index, E element) 메소드를 이용했다. 실행 결과를 보면 LinkedList가 훨씬 빠르다.

<pre>
<code>
import java.util.*;

public class Main {
    public static void main(String[] args) {
        List<String> list1 = new ArrayList<String>();
        List<String> list2 = new LinkedList<String>();

        long startTime;
        long endTime;

        startTime = System.nanoTime();
        for(int i = 0; i < 10000; i++) {
            list1.add(0, String.valueOf(i));
        }

        endTime = System.nanoTime();
        System.out.println("ArrayList = " + (endTime-startTime) + " ns");

        startTime = System.nanoTime();
        for(int i = 0; i < 10000; i++) {
            list2.add(0, String.valueOf(i));
        }
        endTime = System.nanoTime();
        System.out.println("LinkedList = " + (endTime-startTime) + " ns");
    }
}
</code>
</pre>

끝에서부터(순차적으로) 추가/삭제하는 경우 ArrayList가 빠르지만 중간에 추가 또는 삭제할 경우에는 앞뒤 링크 정보만 변경하면 되는 LinkedList가 더 빠르다. Arraylist는 뒤쪽 인덱스들을 모두 1씩 증가 또는 감소시키는 시간이 필요하므로 처리 속도가 느리다.

| 구분 | 순차적으로 추가/삭제 | 중간에 추가/삭제 | 검색 |
| --- | --- | --- | --- |
| ArrayList | 빠르다 | 느리다 | 빠르다 |
| LinkedList | 느리다 | 빠르다 | 느리다 |

## Set 컬렉션

List 컬렉션은 저장 순서를 유지하지만 [Set컬렉션](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html)은 저장 순서가 유지되지 않는다. 또한 객체를 중복해서 저장할 수 없고, 하나의 null만 저장할 수 있다. Set 컬렉션은 수학의 집합에 비유될 수 있다. 집합은 순서와 상관없고 중복이 허용되지 않는다. Set 컬렉션은 또한 구슬 주머니와도 같다. 동일한 구슬을 두 개 넣을 수 없고, 들어갈(저장할) 때의 순서와 나올(찾을) 때의 순서가 다를 수 있기 때문이다.

아래는 Set 인터페이스의 메소드이다. 인덱스로 관리하지 않기 때문에 인덱스를 매개값으로 갖는 메소드가 없다.

![Set 컬렉션](./image/java_chapter15_6.png)

메소드 매개 변수 타입과 리턴 타입의 E라는 타입 파라미터가 사용되는 이유는 Set 인터페이스가 제네릭 타입이기 때문이다. 구체적인 타입은 구현 객체를 생성할 때 결정된다. 

아래 코드는 Set 컬렉션에 저장되는 구체적인 타입을 String으로 정해놓고 String 객체를 저장, 삭제한다.

<pre>
<code>
Set<String> set = ...;
set.add("Park");
set.add("Hong");

set.remove("Hong");
</code>
</pre>

Set 컬렉션은 인덱스로 객체를 검색해서 가져오는 메소드가 없다. 따라서 전체 객체를 한번씩 반복해서 가져오는 반복자(Iterator)를 사용한다. 반복자 Iterator 인터페이스를 구현하여 iterator() 메소드를 호출하면 된다.

<pre>
<code>
Set<String> set = ...;
Iterator<String> iterator = set.iterator();
</code>
</pre>

다음은 Iterator 인터페이스에 선언된 메소드이다.

| 리턴 타입 | 메소드명 | 설명 | 
| --- | --- | --- | 
| boolean | hasNext() | 가져올 객체가 있으면 true를 리턴하고 없으면 false를 리턴한다. |
| E | next() | 컬렉션에서 하나의 객체를 가져온다. |
| void | remove() | Set 컬렉션에서 객체를 제거한다. |

Iterator에서 하나의 객체를 가져올 때 next() 메소드를 사용한다. next()를 사용하기 전에 먼저 가져올 객체가 있는지 hasNext() 메소드로 확인하는 것이 좋다. 객체가 있어서 true를 리턴하면 next() 메소드를 사용한다. 

아래 코드는 Set 컬렉션에서 String 객체들을 반복해서 하나씩 가져오는 코드이다.

<pre>
<code>
Set<String> set = ...;
Iterator<String> iterator = set.iterator();

while(iterator.hasNext()) { // 저장된 객체 수만큼 루핑.
    // next() 메소드로 String 객체를 하나 가져온다.
    String str = iterator.next();
}
</code>
</pre>

Iterator를 사용하지 않더라도 향상된 for문을 이용해서 전체 객체를 대상으로 반복할 수 있다.

<pre>
<code>
Set<String> set = ...;
for(String str : set) {

}
</code>
</pre>

Set 컬렉션에서 Iterator의 next() 메소드로 가져온 객체를 제거하고 싶다면 remove() 메소드를 호출한다. Iterator의 메소드이지만 Set 컬렉션에서 객체가 제거된다는 사실을 기억해야 한다. 

<pre>
<code>
Set<String> set = ...;
Iterator<String> iterator = set.iterator();

while(iterator.hasNext()) { // 저장된 객체 수만큼 루핑.
    // next() 메소드로 String 객체를 하나 가져온다.
    String str = iterator.next();

    if(str.equals("Hong")){
        iterator.remove();
    }
}
</code>
</pre>

### HashSet

[HashSet](https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html)은 Set 인터페이스의 구현 클래스이다. HashSet을 생성하기 위해서는 다음과 같이 기본 생성자를 호출한다.

<pre>
<code>
Set<E> set = new HashSet<E>();
</code>
</pre>

타입 파라미터 E에는 컬렉션에 저장할 객체 타입을 지정한다. 예를 들어 String 객체를 저장하는 HashSet은 다음과 같이 생성한다.

<pre>
<code>
Set<String> set = new HashSet<String>();
</code>
</pre>

HashSet은 **객체들을 순서 없이 저장하고 동일한 객체는 중복 저장하지 않는다.** HashSet이 판단하는 동일 객체란 꼭 같은 인스턴스를 뜻하지는 않는다. HashSet은 객체를 저장하기 전에 먼저 객체의 hashCode() 메소드를 호출해서 해시코드를 얻어낸다. 그리고 이미 저장되어 있는 객체들의 해시코드와 비교한다. 만약 동일한 해시코드가 있다면 다시 equals() 메소드로 두 객체를 비교해서 true가 나오면 동일 객체로 판단하고 중복 저장을 하지 않는다.

![HashSet](./image/java_chapter15_7.png)

문자열을 HashSet에 저장할 경우 같은 문자열을 갖는 String 객체는 동등한 객체로 간주되고 다른 문자열을 갖는 String 객체는 다른 객체로 간주된다. 그 이유는 String 클래스가 hashCode()와 equals() 메소들르 재정의해서 같은 문자열일 경우 hashCode()의 리턴값을 같게, equals()의 리턴값은 true가 나오게 하게 때문이다. 

아래 코드는 HashSet에 String 객체를 추가, 검색, 제거하는 코드이다.

<pre>
<code>
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Set<String> set = new HashSet<String>();

        set.add("A1");
        set.add("A2");
        set.add("A3");

        int size = set.size();
        System.out.println("총 객체 수 = " + size); // 3

        Iterator<String> iterator = set.iterator();
        while(iterator.hasNext()) {
            String element = iterator.next(); // 객체 하나씩 꺼내오기
            System.out.println(element);
        }

        set.remove("A2");

        System.out.println("총 객체 수 = " + size); // 2

        iterator = set.iteartor();
        while(iterator.hasNext()) {
            String element = iterator.next();
            System.out.println(element);
        }

        set.clear(); // 코든 객체를 제거하고 비운다.
        if(set.isEmpty()) {
            System.out.println("- Empty -");
        }
    }
}
</code>
</pre>

아래 코드는 사용자 정의 클래스 Member를 만들고 hashCode()와 equals() 메소드를 오버라이딩 했다. 인스턴스가 달라도 이름과 나이가 동일하면 동일 객체로 간주하여 중복 저장되지 않도록 하기 위해서이다.

<pre>
<code>
public class Member {
    public String name;
    public int age;

    public Member(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if(obj instanceof Member) {
            Member member = (Member) obj;
            return member.name.equals(name) && (member.age == age);
        }else{
            return false;
        }
    }

    @Override
    public int hashCode() { // name과 age값이 같으면 동일한 hashCode가 리턴
        return name.hashCode() + age;
    }
}

import java.util.*;

public class Main {
    public static void main(String[] args) {
        Set<member> set = new HashSet<Member>();

        set.add(new Member("Hong", 15));
        set.add(new Member("Hong", 15));

        System.out.println("총 객체수 = " + set.size()); // 1
    }
}
</code>
</pre>

## Map 컬렉션

[Map 컬렉션](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html)은 키(key), 값(value)으로 구성된 Entry 객체를 저장하는 구조를 가지고 있다. 여기서 키와 값은 모두 객체이다. 키는 중복 저장될 수 없지만 값은 중복 저장될 수 있다. 만약 기존에 저장된 키와 동일한 키로 값을 저장하면 기존 값은 없어지고 새로운 값으로 대치된다.

Map 컬렉션에는 HashMap, Hashtable, LinkedHashMap, Properties, TreeMap 등이 있다. 

![Map 컬렉션](./image/java_chapter15_8.png)

메소드의 매개 변수 타입과 리턴 타입에 K와 V라는 타입 파라미터가 있는데, 이것은 Map 인터페이스가 제네릭 타입이기 때문이다. 구체적인 타입은 구현 객체를 생성할 때 결정된다. 

키를 알고 싶다면 get() 메소드로 간단하게 객체를 찾아오면 되지만, 저장된 전체 객체를 대상으로 하나씩 얻고 싶을 경우에는 두 가지 방법을 사용할 수 있다. 첫 번째는 keySet() 메소드로 모든 키를 Set 컬렉션으로 얻은 다음, 반복자를 통해 키를 하나씩 얻고 get() 메소드를 통해 값을 얻는다.

<pre>
<code>
Map<K, V> map = ...;
Set<K> keySet = map.keySet();
Iterator<K> keyIterator = keySet.iterator();
while(keyIterator.hasNext()) {
    K key = keyIterator.next();
    V value = map.get(key);
}
</code>
</pre>

두 번째 방법은 entrySet() 메소드로 모든 Map.Entry를 Set 컬렉션으로 얻은 다음 반복자를 통해 Map.Entry를 하나씩 얻고 getKey()와 getValue() 메소드를 이용해 키와 값을 얻으면 된다.

<pre>
<code>
Set<Map.Entry<K,V>> entrySet = map.entrySet();
Iterator<Map.Entry<K,V>> entryIterator = entrySet.iterator();
while(entryIterator.hasNext()) {
    Map.Entry<K,V> entry = entryIterator.next();
    K key = entry.getKey();
    V value = entry.getValue();
}
</code>
</pre>

### HashMap

[HashMap](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html)은 Map 인터페이스를 구현한 대표적인 Map 컬렉션이다. HashMap의 키로 사용할 객체는 hashCode()와 equals() 메소드를 재정의해서 동등 객체가 될 조건을 정해야 한다. 동등 객체, 즉 동일한 키가 될 조건은 hashCode()의 리턴값이 같아야 하고 equals() 메소드가 true를 리턴해야 한다.

HashMap 생성은 키 타입과 값 타입을 파라미터로 주고 기본 생성자를 호출하면 된다.

<pre>
<code>
Map<K, V> map = new HashMap<K, V>();
</code>
</pre>

키와 값의 타입은 기본 타입(byte, short, int, float, double, boolean, char)을 사용할 수 없다. 클래스 및 인터페이스 타입만 가능하다.
아래 코드는 이름을 키, 점수를 값으로 저장하는 HashMap을 사용한다.

<pre>
<code>
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class Main {
    public static void main(String[] args) {
        // Map 컬렉션 생성
        Map<String, Integer> map = new HashMap<String, Integer>();

        // 객체 저장
        map.put("A1", 1);
        map.put("A2", 2);
        map.put("A3", 3);
        System.out.println(map.size()); // 3

        // 객체를 하나씩 처리
        Set<String> keySet = map.keySet();
        Iterator<String> keyIterator = keySet.iterator();
        while(keyIterator.hasNext()) {
            String key = keyIterator.next();
            Integer value = map.get(key);
            System.out.println(key + " " + value);
        }

        // 객체 삭제
        map.remove("A1");

        // 객체를 하나씩 처리
        Set<Map.Entry<String, Integer>> entrySet = map.entrySet();
        Iterator<Map.Entry<String, Integer>> entryIterator = entrySet.iterator();

        while(entryIterator.hasNext()) {
            Map.Entry<String, Integer> entry = entryIterator.next();
            String key = entry.getKey();
            Integer value = entry.getValue();
            System.out.println(key + " " + value);
        }
    }
}
</code>
</pre>

아래 코드는 사용자 정의 객체 Student를 키로 하여 점수를 저장하는 HashMap 사용 방식을 보여준다.
학번과 이름이 동일한 Student를 동등 키로 간주하기 위해 Student 클래스에는 hashCode()와 equals() 메소드가 재정의되어 있다.

<pre>
<code>
class Student {
    public int sno;
    public String name;

    public Student(int sno, String name) {
        this.sno = sno;
        this.name = name;
    }

    public boolean equals(Object obj) { // 학번과 이름이 동일한 경우 true를 리턴
        if(obj instanceof Student) {
            Student student = (Student) obj;
            return (sno == student.sno) && (name.equals(student.name));
        }else{
            return false;
        }
    }

    public int hashCode() { // 학번과 이름이 같다면 동일 값 리턴
        return sno + name.hashCode();
    }
}

import java.util.*;

public class Main {
    public static void main(String[] args) {
        Map<Student, Integer> map = new HashMap<Student, Integer>();

        // 학번과 이름이 동일한 Student를 키로 저장
        map.put(new Student(1, "Park"), 95);
        map.put(new Student(1, "Park"), 95);

        System.out.println("The number of Entry = " + map.size()); // 1
    }
}
</code>
</pre>

### Hashtable

[Hashtable](https://docs.oracle.com/javase/8/docs/api/java/util/Hashtable.html)은 HashMap과 동일한 내부 구조를 가지고 있다. Hashtable도 키로 사용할 객체는 hashCode()와 equals() 메소드를 재정의해서 동등 객체가 될 조건을 정해야 한다. 

HashMap과의 차이점은 Hashtable은 동기화된(synchronized) 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드들을 실행할 수는 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다. 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다. 이것을 스레드가 안전(thread safe)하다라고 말한다.

Hashtable 생성 방법은 아래와 같다. 키 타입과 값 타입을 지정하고 기본 생성자를 호출한다.

<pre>
<code>
Map<K, V> map = new Hashtable<K, V>();
</code>
</pre>

키로 String, 값으로 Integer 타입을 사용하는 Hashtable 생성자의 모습이다.

<pre>
<code>
Map<String, Integer> map = new Hashtable<String, Integer>();
</code>
</pre>

아래 코드는 키보드로 아이디와 비밀번호를 입력받아 Hashtable에 저장되어 있는 키(아이디)와 값(비밀번호)으로 비교한 후 로그인 여부를 출력한다.

<pre>
<code>
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Map<String, String> map = new Hashtable<String, String>();

        // 아이디, 비밀번호를 미리 저장
        map.put("A", "11");
        map.put("B", "22");
        map.put("C", "33");

        // 입력된 내용을 받는다
        Scanner scanner = new Scanner(System.in);

        whlie(true) {
            System.out.println("Input the ID and Pwd);
            System.out.print("ID = ");
            String id = scanner.nextLine();

            System.out.println("Pwd = ");
            String pwd = scanner.nextLine();
            System.out.println();

            if(map.containsKey(id)) {
                if(map.get(id).equals(password)) {
                    System.out.println("Success");
                    break;
                }else {
                    System.out.println("invalid password");
                }
            }else {
                System.out.println("invalid id");
            }
        }
    }
}
</code>
</pre>


# 출처
* [이것이 자바다](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788968481475&orderClick=LAG&Kc=)
