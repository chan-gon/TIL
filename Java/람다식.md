# 람다식

람다식(Lambda Expressions)은 익명 함수(anonymous function)를 생성하기 위한 식으로 객체 지향 언어보다는 함수 지향 언어에 가깝다.
람다식의 형태는 매개 변수를 가진 코드 블록이지만, 런타임 시에는 익명 구현 객체를 생성한다.

> 람다식 -> 매개 변수를 가진 코드 블록 -> 익명 구현 객체

예를 들어 Runnable 인터페이스의 익명 구현 객체를 생성하는 전형적인 코드는 아래와 같다.

<pre>
<code>
Runnable runnable = new Runnable() {
    public void run() {
        ...
    }
};
</code>
</pre>

위 코드에서 익명 구현 객체를 람다식으로 표현하면 다음과 같다.

<pre>
<code>
Runnable runnable = () -> { ... };
</code>
</pre>

람다식은 "(매개변수) -> {실행코드}" 형태로 작성된다. 함수 정의 형태를 띠고 있지만 런타임 시 인터페이스의 익명 구현 객체로 생성된다. 어떤 인터페이스를 구현할 것인가는 대입되는 인터페이스에 달려있다. 위 코드는 Runnable 변수에 대입되므로 람다식은 Runnable의 익명 구현 객체를 생성하게 된다.

## 람다식 기본 문법

<pre>
<code>
(타입 매개변수, ...) -> {실행문; ...}
</code>
</pre>

(타입 매개변수, ...)는 오른쪽 중괄호 {} 블록을 실행하기 위해 필요한 값을 제공한다. 매개 변수의 이름은 자유롭게 설정할 수 있다. -> 기호는 매개 변수를 이용해서 중괄호 {}를 실행한다는 뜻이다. 예를 들어 int 매개 변수 ace의 값을 콘솔에 출력하기 위해 다음과 같이 람다식을 작성한다.

<pre>
<code>
(int ace) -> { System.out.println(ace); }
</code>
</pre>

매개 변수 타입은 런타임 시 대입되는 값에 따라 자동으로 인식될 수 있기 때문에 람다식에서는 매개 변수의 타입을 일반적으로 언급하지 않는다. 따라서 위 코드는 다음과 같이 작성할 수 있다.

<pre>
<code>
(ace) -> { System.out.println(ace); }
</code>
</pre>

하나의 매개 변수만 있다면 괄호 ()를 생략할 수 있고, 하나의 실행문만 있다면 중괄호 {}도 생략할 수 있다. 따라서 위 코드는 다음과 같이 작성할 수 있다.

<pre>
<code>
ace -> System.out.println(ace)
</code>
</pre>

만약 매개 변수가 없다면 람다식에서 매개 변수 자리가 없어지므로 다음과 같이 빈 괄호 ()를 반드시 사용해야 한다.

<pre>
<code>
() -> { 실행문; ... }
</code>
</pre>

중괄호 {}를 실행하고 결과값을 리턴해야 한다면 다음과 같이 return문으로 결과값을 지정할 수 있다.

<pre>
<code>
(x, y) -> { return x * y; };
</code>
</pre>

중괄호 {}에 return문만 있을 경우 람다식에서는 return문을 사용하지 않고 다음과 같이 작성하는 것이 일반적이다.

<pre>
<code>
(x, y) -> return x * y
</code>
</pre>

## 타겟 타입과 함수적 인터페이스

자바의 메소드는 단독으로 선언될 수 없고 항상 클래스의 구성 멤버로 선언되어야 하기 때문에 람다식은 단순히 메소드를 선언하는 것이 아니라 이 메소드를 가지고 있는 객체를 생성해 낸다.

> 인터페이스 변수 = 람다식;

람다식은 인터페이스 변수에 대입되는데, 이는 람다식은 인터페이스의 익명 구현 객체를 생성한다는 뜻이다. 인터페이스는 직접 객체화할 수 없기 때문에 구현 클래스가 필요한데, 람다식은 익명 구현 클래스를 생성하고 객체화한다. 람다식은 대입될 인터페이스의 종류에 따라 작성 방법이 달라지기 때문에 람다식이 대입될 인터페이스를 람다식의 타겟 타입(target type)이라고 한다.

### 함수적 인터페이스(@FunctionalInterface)

모든 인터페이스를 람다식의 타겟 타입으로 사용할 수는 없다. 람다식이 하나의 메소드를 정의하기 때문에 두 개 이상의 추상 메소드가 선언된 인터페이스는 람다식을 이용해서 구현 객체를 생성할 수 없다. 하나의 추상 메소드가 선언된 인터페이스만이 람다식의 타겟 타입이 될 수 있다. 이러한 인터페이스를 함수적 인터페이스(functional interface)라고 한다. 함수적 인터페이스 작성 시 두 개 이상의 추상 메소드가 선언되지 않도록 컴파일러가 체킹해주는 기능이 있는데, 인터페이스 선언 시 @FunctionalInterface 어노테이션을 사용하면 된다. 이 어노테이션은 두 개 이상의 추상 메소드 작성 시 컴파일 오류를 발생시킨다.

<pre>
<code>
@FunctionalInterface
public interface MyFunctionalInterface {
    public void method1();
    public void method2(); // 컴파일 오류 발생
}
</code>
</pre>

@FunctionalInterface 어노테이션은 선택사항이다.(Optional) 이 어노테이션이 없어도 하나의 추상 메소드만 있다면 모두 함수적 인터페이스이다. 
람다식은 타겟 타입인 함수적 인터페이스가 가지고 있는 추상 메소드 선언 형태에 따라 작성 방법이 달라진다.

### 매개 변수와 리턴값이 없는 람다식

아래에 매개 변수와 리턴값이 없는 추상 메소드를 가진 함수적 인터페이스가 있다.

<pre>
<code>
@FunctionalInterface
public interface MyFunctionalInterface {
    public void method();
}
</code>
</pre>

이 인터페이스를 타겟 타입으로 갖는 람다식은 아래와 같다. 람다식에서 매개 변수가 없는 이유는 method()가 매개 변수를 가지지 않기 때문이다.

<pre>
<code>
MyFunctionalInterface fi = () -> { ... }
</code>
</pre>

람다식이 대입된 인터페이스의 참조 변수는 다음과 같이 method()를 호출할 수 있다. method() 호출은 람다식의 중괄호 {}를 실행시킨다.

<pre>
<code>
public class Main {
    public static void main(String[] args) {
        MyFunctionalInterface fi;

        fi = () -> {
            String str = "method call1";
            System.out.println(str);
        };
        fi.method();

        fi = () -> { System.out.println("method call2"); };
        fi.method();

        fi = () -> System.out.println("method call3"); // 실행문이 하나라면 중괄호 {}는 생략 가능
        fi.method();
    }
}

결과)
method call1
method call2
method call3
</code>
</pre>

### 매개 변수가 있는 람다식

<pre>
<code>
@FunctionalInterface
public interface MyFunctionalInterface {
    public void method(int x);
}
</code>
</pre>

위 코드와 같이 매개 변수가 있는 함수적 인터페이스의 람다식은 다음과 같은 형태로 작성해야 한다.
매개 변수 개수에 맞추어 람다식 매개 변수를 설정한다.

<pre>
<code>
MyFunctionalInterface fi = (x) -> { ... }
또는
MyFunctionalInterface fi = x -> { ... }
</code>
</pre>

<pre>
<code>
public class Main {
    public static void main(String[] args) {
        MyFunctionalInterface fi;

        fi = (x) -> {
            int result = x * 2;
            System.out.println(result);
        };
        fi.method(2);

        fi = x -> System.out.println( x * 2 );
        fi.method(3);
    }
}

결과)
4
6
</code>
</pre>

### 리턴값이 있는 람다식

<pre>
<code>
@FunctionalInterface
public interface MyFunctionalInterface {
    public int method(int x, int y);
}
</code>
</pre>

매개 변수와 리턴 타입이 있는 함수적 인터페이스의 람다식은 아래와 같이 작성한다.

<pre>
<code>
MyFunctionalInterface fi = (x, y) -> { ...; return 값; }
</code>
</pre>

<pre>
<code>
public class Main {
    public static void main(String[] args) {
        MyFunctionalInterface fi;

        fi = (x, y) -> {
            int result = x * y;
            return result;
        };
        System.out.println(fi.method(2,5));

        fi = (x, y) -> { return x * y; };
        System.out.println(fi.method(2,6));

        fi = (x, y) -> x * y;
        System.out.println(fi.method(2,7));

    }
}

결과)
10
12
14
</code>
</pre>

## 클래스 멤버와 로컬 변수 사용

람다식의 실행 블록에는 클래스의 멤버(필드와 메소드) 및 로컬 변수를 사용할 수 있다. 클래스의 멤버는 제약 사항 없이 사용 가능하지만, 로컬 변수는 제약 사항이 따른다.

### 클래스의 멤버 사용

람다식 실행 블록에는 클래스의 멤버인 필드와 메소드를 제약 사항 없이 사용할 수 있다. 하지만 this 키워드 사용 시 주의가 필요하다. 일반적으로 익명 객체 내부에서 this는 익명 객체의 참조이지만, 람다식에서 this는 내부적으로 생성되는 익명 객체의 참조가 아니라 람다식을 실행한 객체의 참조이다. 

<pre>
<code>
public interface MyFunctionalInterface {
    public void method();
}

public class UsingThis {
    public int outterField = 10;

    class Inner {
        int innerField = 20;

        void method() {
            // 람다식
            MyFunctionalInterface fi = () -> {
                System.out.println(outterField);
                System.out.println(UsingThis.this.outterField);

                System.out.println(innerField);
                System.out.println(this.innerField);
            };
            fi.method();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        UsingThis usingThis = new UsingThis();
        UsingThis.Inner inner = usingThis.new Inner();
        inner.method();
    }
}

결과)
10
10
20
20
</code>
</pre>

### 로컬 변수 사용

람다식은 메소드 내부에서 주로 작성되기 때문에 로컬 익명 구현 객체를 생성시킨다고 봐야 한다. 람다식에서 바깥 클래스의 필드나 메소드는 제한 없이 사용할 수 있으나, 메소드의 매개 변수 또는 로컬 변수를 사용하면 이 두 변수는 final 특성을 가져야 한다. 따라서 매개 변수 또는 로컬 변수를 람다식에서 읽는 것은 허용되지만 람다식 내부 또는 외부에서 변경할 수 없다.

<pre>
<code>
public interface MyFunctionalInterface {
    public void method();
}

public class UsingLocalVariable {
    void method(int arg) {
        int localVar = 40;

        // final 특성 때문에 수정 불가
        arg = 30;
        localVar = 41;

        // 람다식
        MyFunctionalInterface fi = () -> {
            // 로컬 변수 읽기
            System.out.println(arg);
            System.out.println(localVar);
        };
        fi.method();
    }
}

public class Main {
    public static void main(String[] args) {
        UsingLocalVariable uiv = new UsingLocalVariable();
        uiv.method(20);
    }
}
</code>
</pre>

# 출처
* [이것이 자바다](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788968481475&orderClick=LAG&Kc=)
