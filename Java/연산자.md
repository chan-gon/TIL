# 연산자와 연산식

우선 용어 정리부터 해보자.

| 용어 | 의미 |
| --- | --- |
| 연산(expression) | 프로그램에서 데이터를 처리하여 결과를 산출하는 것 |
| 연산자(operator) | 연산에 사용되는 표시나 기호 |
| 피연산자(operand) | 연산되는 데이터 |

다음 예시는 연산자와 피연산자의 사용을 보여준다.
+, -, *, / 기호는 연산자. x, y는 피연산자이다.
<pre>
<code>
x + y;
x - y;
x * y;
x / y;
</code>
</pre>

자바에서 제공하는 다양한 연산자 종류

| 연산자 종류 | 연산자 | 피연산자 수 | 산출값 | 기능 설명 |
| --- | --- | --- | --- | --- |
| 산술 | +, -, *, /, % | 이항 | 숫자 | 사칙연산 및 나머지 계산 |
| 부호 | +, - | 단항 | 숫자 | 음수와 양수의 부호 |
| 문자열 | + | 이항 | 문자열 | 두 문자열을 연결 |
| 대입 | =, +=, -=, *=, /=, %=, &=, ^=, !=, <<=, >>=, >>>= | 이항 | 다양 | 우변의 값을 좌변의 변수에 대입 |
| 증감 | ==, !=, >, <, >=, <=, instanceof | 이항 | boolean | 값의 비교 |
| 논리 | !, &, |, &&, || | 단항, 이항 | boolean | 논리적NOT, AND, OR 연산 |
| 조건 | (조건식)? A : B | 삼항 | 다양 | 조건식에 따라 A 또는 B 중 하나를 선택한다 |
| 비트 | ~, &, |, ^ | 단항, 이항 | 숫자, boolean | 비트 NOT, AND, OR, XOR 연산 |
| 쉬프트 | >>, <<, >>> | 이항 | 숫자 | 비트를 좌측/우측으로 밀어서 이동 |

연산자는 필요로 하는 피연산자의 수에 따라 단항, 이상, 삼항으로 구분된다. 

<pre>
<code>
단항 연산자: x++;
이항 연산자: x + y;
삼항 연산자: (sum>90) ? "A" : "B";
</code>
</pre>

연산식은 반드시 **하나의 값만** 산출한다. 연산자 수가 아무리 많아도 두 개 이상의 값을 산출하지 않는다.
일반적으로 연산식의 값은 아래 예시와 같이 변수에 저장하여 사용한다.
<pre>
<code>
// 연산식의 값은 변수에 저장하여 사용한다.
int result = x + y;
</code>
</pre>

연산식은 다른 연산식의 피연산자로도 사용 가능하다.
아래 예시는 비교 피연산자인 < 의 좌측 피연산자로 (x+y)라는 연산식이 사용되었다.
<pre>
<code>
boolean result = (x+y) < 5;
</code>
</pre>

## 연산자의 방향과 우선순위
> 프로그램에서는 연산자의 연산 방향과 연산자 간의 우선순위가 정해져 있다.

아래 예시를 살펴보자.
<pre>
<code>
x > 0 && y < 0
</code>
</pre>
&& 보다는 >, < 가 우선순위가 높기 때문에 x > 0, y < 0 가 먼저 처리되고 &&는 x > 0, y < 0 의 산출값을 가지고 연산한다.

**우선순위가 같은 경우**는 어떻게 할까?
이 경우 **연산자의 방향**에 따라 달라진다.
아래 예시를 살펴보자.
<pre>
<code>
100 * 2 / 3 % 5
</code>
</pre>
*, /, % 는 같은 우선순위를 가지고 있다. 이 연산자들은 왼쪽에서 오른쪽으로 연산을 수행한다.
따라서 100 * 2가 가장 먼저 연산된다. 연산 순서에 따라 연산을 하면.
1. 100 * 2 = 200
2. 200 / 3 = 66
3. 66 % 5 = 1
최종 결과값은 1이 나온다.

하지만 **단항 연산자(++, --, ~, !), 부호 연산자(+, -), 대입 연산자(=, +=, -=, ...)는 오른쪽에서 왼쪽**으로 연산된다.
아래 예시를 살펴보자.
<pre>
<code>
a = b = c = 7;
</code>
</pre>
위 연산식의 연산 순서는 다음과 같다.
1. c = 7
2. b = c
3. a = b
최종 결과값은 a, b, c 모두 값이 7이 된다.

연산자의 연산 방향과 우선순위

![연산자의 연산 방향과 우선순위](./image/chapter3_1.png)

이것저것 복잡하게 우선순위나 방향을 고려하기 귀찮다면 괄호()를 사용하는 것을 추천한다.
괄호를 사용하면 괄호 안의 연산식이 우선순위로 처리된다.
아래 예시를 살펴보자.
<pre>
<code>
int num1 = 1;
int num2 = 2;
int num3 = 3;
int result = (num1 + num2) * num3;
</code>
</pre>
원래대로라면 num2 * num3가 우선적으로 연산되지만, (num1 + num2)와 같이 괄호로 묶어주면 해당 부분의 연산이 최우선순위를 가지도록 할 수 있다.

## 단항 연산자
> 단항 연산자는 피연산자가 단 하나뿐인 연산자를 말한다.

단항 연산자의 종류
* 부호 연산자(+, -)
* 증감 연산자(++, --)
* 부정 연산자( ! )
* 비트 반전 연산자( ~ )

### 부호 연산자
부호 연산자는 boolean 타입과 char 타입을 제외한 나머지 기본 타입에 사용 가능하다.

산술 연산자는 부호 연산자, 산술 연산자 두 역할 수행한다.
아래 예시를 살펴보자.
<pre>
<code>
int a1 = +100;
int a2 = -100;
double b1 = -3.14;
double b2 = -10.34;
</code>
</pre>
정수 리터럴 앞에 부호 연산자를 붙여 양수 및 음수를 표현한다.

리터럴 앞이 아닌 변수 앞에 붙어있는 경우도 있다. 이 경우는 변수를 양수 및 음수로 표현한 것이 아니고, 변수 값의 부호를 유지하거나 바꾸기 위함이다.
아래 예시를 살펴보자.
<pre>
<code>
int a1 = +100;
int result1 = +a1;
int result2 = -a1;
</code>
</pre>
result1에는 + 부호 연산자를 붙여 양수를 유지한다. 반면 result2에서는 음수 부호 연산자를 사용해 음수로 변경한다.

**부호 연산자의 산출 타입은 int타입**이다.
따라서 다른 타입 값을 부호 연산하면 int 값으로 바뀌기 때문에 컴파일 에러가 발생한다.
아래 예시를 살펴보자.
<pre>
<code>
short s = 100;
short result = -s; // 컴파일 에러 발생
</code>
</pre>

다음과 같이 변경해야 한다.
<pre>
<code>
short s = 100;
int result = -s;
</code>
</pre>

### 증감 연산자
증감 연산자는 변수의 값을 1증가(++) 또는 감소(--)시키는 연산자.
boolean타입을 제외한 모든 기본 타입의 피연산자에 사용할 수 있다.

| 연산식 | 설명 |
| --- | --- |
| ++피연산자 | 다른 연산을 수행하기 전에 피연산자의 값을 1 증가시킴 |
| --피연산자 | 다른 연산을 수행하기 전에 피연산자의 값을 1 감소시킴 |
| 피연산자++ | 다른 연산을 수행한 후에 피연산자의 값을 1 증가시킴 |
| 피연산자-- | 다른 연산을 수행한 후에 피연산자의 값을 1 감소시킴 |

위 표에서 알 수 있듯이 연산식에서 증감 연산자의 위치에 따라 연산식의 결과가 달라질 수 있으니 주의해야 한다.
아래 예시를 살펴보자.
<pre>
<code>
int x = 1;
int y = 1;
int result1 = ++x + 10; // 12
int result2 = y++ + 10; // 11
</code>
</pre>
result1은 피연산자 x의 값을 우선 1 증가시킨 후 10을 더한다. 따라서 결과는 12
result2는 우선 피연산자에 10을 더하기 때문에 결과가 11이 나온다. 11이 나온 이후에 y의 증감 연산자가 수행되어 y는 2가 된다.

### 논리 부정 연산자
논리 부정 연산자는 '!'기호를 사용하여 true를 false로, false를 true로 변경한다. 따라서 boolean 타입에만 사용할 수 있다.

| 연산식 | 설명 |
| --- | --- |
| !피연산자 | 피연산자가 true이면 false값 산출 / 피연산자가 false이면 true값 산출 |

### 비트 반전 연산자
정수 타입(byte, short, int, long)의 피연산자에만 사용되며, 피연산자를 2진수로 표현했을 때 비트값이 0을 1로, 1은 0으로 반전한다.
'~'기호를 사용한다.

사용 시 주의점은 비트 반전 연산자 산출 타입은 int 타입이 된다는 것이다.
피연산자는 연산을 수행하기 전에 int타입으로 변환되고, 비트 반전이 일어난다.
아래 예시를 살펴보자.
<pre>
<code>
byte a1 = 10;
byte a2 = ~a1; // 컴파일 에러
</code>
</pre>

다음과 같이 변경해야 한다.
<pre>
<code>
byte a1 = 10;
int a2 = ~a1;
</code>
</pre>

비트 반전 연산자의 결과를 이용해 부호가 반대인 정수도 구할 수 있다.
비트 반전 연산자의 산출값에 1을 더하면 부호가 반대인 정수를 얻을 수 있다. 
아래 예시를 살펴보자.
<pre>
<code>
byte a1 = 10;
int a2 = ~a1 + 1; // -10
</code>
</pre>
10을 비트 반전하면 -11이 되는데, 여기에 1을 더하면 -10을 얻는다.

## 이항 연산자
이항 연산자는 피연산자가 두 개인 연산자를 말한다.

### 산술 연산자
일반적인 사칙연산을 떠올리면 된다.

| 연산식 | 설명 |
| --- | --- |
| 피연산자 + 피연산자 | 덧셈 연산 |
| 피연산자 - 피연산자 | 뺄셈 연산 |
| 피연산자 * 피연산자 | 곱셈 연산 |
| 피연산자 / 피연산자 | 좌측 피연산자를 우측 피연산자로 나눗셈 연산 |
| 피연산자 % 피연산자 | 좌측 피연산자를 우측 피연산자로 나눈 나머지를 구하는 연산 |

long 타입을 제외한 정수의 산술 연산은 무조건 int 타입으로 변환 후 연산을 수행해야 한다.
다음 예시를 살펴보자.
<pre>
<code>
byte a1 = 10;
byte a2 = 10;
byte result = a1 + a2; // 컴파일 에러 발생
</code>
</pre>
컴파일 에러가 발생하는 이유는, 앞서 설명 했듯이 long 타입 제외 모든 정수의 산술 연산은 int 타입으로 변환 후 연산을 수행하고, 산출 타입이 int이기 때문이다. 따라서 다음과 같이 변경해야 한다.
<pre>
<code>
byte a1 = 10;
byte a2 = 10;
int result = a1 + a2;
</code>
</pre>

**정수 타입 연산의 결과가 int 타입으로 나오는 이유**는 JVM은 기본적으로 32비트 단위로 계산하기 때문이다.

char 타입도 정수 타입이므로 산술 연산이 가능하다.
다음 예시를 살펴보자.
<pre>
<code>
char c1 = 'A' + 1; // 성공
char c2 = 'A';
char c3 = c2 + 1; // 컴파일 에러 발생
</code>
</pre>
자바는 리터럴 간의 연산은 타입 변화 없이 해당 타입으로 계산한다. 따라서 c1의 문자 A는 유니코드 65를 뜻하고, 거기에 1을 더하면 66, 즉 char 타입으로 알파벳 B가 된다. 
c3의 경우 변수 c2에 1을 더하면 c2는 int 타입으로 변하여 1과 연산되기 때문에 산출 타입으로 int가 필요하다. 따라서 컴파일 에러가 발생한다. 이를 해결하기 위해 강제 타입 변환(캐스팅)을 해서 char 타입을 산출 타입으로 얻어야 한다.
<pre>
<code>
char c1 = 'A' + 1; // 성공
char c2 = 'A';
char c3 = (char)(c2 + 1); // 컴파일 에러 발생
</code>
</pre>

### NaN과 Infinity 연산
/ 또는 % 연산자를 사용할 시 주의해야 한다. 좌측 피연산자가 정수 타입인 경우 나누는 수인 우측 피연산자는 0을 사용할 수 없다.
만약 0을 사용하여 작업을 수행하면 컴파일은 정상적으로 되지만, 실행 시 에러가 발생한다.
<pre>
<code>
7 / 0 // 에러 발생
3 % 0 // 에러 발생
</code>
</pre>

자바는 프로그램 실행 도중 예외가 발생하면 실행을 즉시 멈추고 프로그램은 종료된다. 따라서 예외 처리가 필요하다.
try, catch를 사용해 예외를 처리한다.
<pre>
<code>
try{
    // y가 0일 경우 예외 발생
    int result = x / y;
    System.out.println("result = " + result);'
} catch(ArithmeticException e){
    System.out.println("0으로 계산하면 안됨");
}
</code>
</pre>

실수 타입인 0.0 또는 0.0f로 나누면 예외가 발생하지 않고, / 연산의 결과는 무한대(Infinity)값을, % 연산의 결과는 NaN(Not a Number)를 가진다.
<pre>
<code>
7 / 0.0 // Infinity
3 % 0.0 // NaN 
</code>
</pre>
하지만 이렇게 예외가 발생하지 않고 Infinity, NaN의 결과를 가진다고 해서 다음 연산을 수행하면 안 된다.
이대로 다음 연산을 수행해도 Infinity, NaN가 산출되어 데이터가 엉망이 된다.

코드에서 /와 %연산의 결과가 Infinity 혹은 NaN인지 확인하려면 Double.isInfinite(), Double,isNaN() 메소드를 이용하면 된다.
이 메소드들은 Double값을 매개값으로 받아 이 값이 Infinity 또는 NaN이라면 true, 그렇지 않다면 false를 리턴한다.
다음 예시를 살펴보자.
<pre>
<code>
int x = 7;
double y = 0.0;

double result = x / y;

System.out.println(Double.isInfinite(result)); // true
System.out.println(Double.isNaN(result)) // false
</code>
</pre>

부동소수점(실수)를 입력받을 때는 반드시 NaN 검사를 해야 한다.
NaN 그 자체로도 산술 연산이 가능하기 때문에 이것과 값이 연산되면 NaN이 저장되어 원래 데이터가 소실된다.
아래 예제를 살펴보자.
<pre>
<code>
String input = "NaN";
double val = Double.valueOf(input); // NaN 값이 저장

double a = 123.0;

a += val; // NaN이 된다

System.out.println(a); // NaN
</code>
</pre>
따라서 NaN을 거를 수 있도록 코드를 구성해야 한다.
아래 예제를 살펴보자.
<pre>
<code>
String input = "NaN";
double val = Double.valueOf(input); // NaN 값이 저장

double a = 123.0;

if(Double.isNaN(val)){
    System.out.println("NaN이 입력되어 처리 불가");
    val = 0.0;
}

a += val;

System.out.println(a); // 123.0
</code>
</pre>
여기서 주의할 점은 NaN 검사를 할 때 반드시 Double.isNaN() 메소드를 사용해야 한다는 것이다. 이 메소드는 매개값이 NaN이라면 true를 리턴한다.
따라서 이 메소드 사용 시 == 연산자를 사용하면 안된다.