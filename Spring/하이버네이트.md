# 하이버네이트

하이버네이트(Hibernate)는 자바 언어를 위한 객체 관계 매핑(Object-Relational Mapping, ORM) 라이브러리 입니다. 객체 지향 도메인 모델을 관계형 데이터베이스로 매핑하기 위한 프레임워크를 제공합니다.

하이버네이트는 Java 환경에서 데이터 영속성(Persistence)을 획득하기 위해 사용합니다. 영속성이란, 영구적인 매체에 데이터를 저장하고, 데이터를 생성한 애플리케이션이 종료된 이후에도 언제든지 데이터를 검색할 수 있는 프로세스를 말합니다. 

하이버네이트 사용을 위한 설정 클래스 입니다.  
자바 코드로 구성했습니다.  
코드는 현재 참고하고 있는 [**전문가를 위한 스프링5** 깃허브 리포지토리](https://github.com/Apress/pro-spring-5)의 코드를 참고했습니다.

### *하이버네이트 사용을 위한 구성*

```
@Configuration
@ComponentScan(basePackages = "com.apress.prospring5.ch7")
@EnableTransactionManagement
public class AppConfig {

	private static Logger logger = LoggerFactory.getLogger(AppConfig.class);

    // 임베디드 H2 데이터베이스 선언
	@Bean
	public DataSource dataSource() {
		try {
			EmbeddedDatabaseBuilder dbBuilder = new EmbeddedDatabaseBuilder();
			return dbBuilder.setType(EmbeddedDatabaseType.H2)
					.addScripts("classpath:sql/schema.sql", "classpath:sql/test-data.sql").build();
		} catch (Exception e) {
			logger.error("Embedded DataSource bean cannot be created!", e);
			return null;
		}
	}

    // 하이버네이트 주요 프로퍼티 등록(어플리케이션 작성을 위해 필수적인 프로퍼티만 정의했음)
	private Properties hibernateProperties() {
		Properties hibernateProp = new Properties();
		hibernateProp.put("hibernate.dialect", "org.hibernate.dialect.H2Dialect");
		hibernateProp.put("hibernate.format_sql", true);
		hibernateProp.put("hibernate.use_sql_comments", true);
		hibernateProp.put("hibernate.show_sql", true);
		hibernateProp.put("hibernate.max_fetch_depth", 3);
		hibernateProp.put("hibernate.jdbc.batch_size", 10);
		hibernateProp.put("hibernate.jdbc.fetch_size", 50);
		return hibernateProp;
	}

	@Bean 
    public SessionFactory sessionFactory() throws IOException {
		LocalSessionFactoryBean sessionFactoryBean = new LocalSessionFactoryBean();
		sessionFactoryBean.setDataSource(dataSource());
		sessionFactoryBean.setPackagesToScan("com.apress.prospring5.ch7.base.entities");
		sessionFactoryBean.setHibernateProperties(hibernateProperties());
		sessionFactoryBean.afterPropertiesSet();
		return sessionFactoryBean.getObject();
	}

	@Bean 
    public PlatformTransactionManager transactionManager() throws IOException {
		return new HibernateTransactionManager(sessionFactory());
	}
}
```

- @ComponentScan(basePackages = "com.apress.prospring5.ch7"): **com.apress.prospring5.ch7** 패키지 아래에서 @Repository 어노테이션이 붙은 컴포넌트를 스캔한다.

- @EnableTransactionManagement: @Transactional 어노테이션을 사용하기 위한 어노테이션. 트랜잭션 처리를 활성화 한다는 의미.

- transactionalManaber 빈: PlatformTransactionManager를 구현한 하이버네이트용 TransactionManager를 등록한다. 스프링에서 @EnableTransactionManagement와 함께 사용되어 @Transactinal 어노테이션을 사용할 수 있게 한다.
- SessionFactory 빈: SessionFactory를 생성한다. 코드를 보면 여러 프로퍼티를 주입한 것을 확인할 수 있다. 
    - 먼저 dataSource 빈을 주입했다. 
    - 그리고 하이버네이트가 지정한 패키지 아래에서 도메인 객체를 스캔하도록 했다. 
    - 그리고 하이버네이트 세부 구성을 hibernateProperties 프로퍼티로 전달했다.

### *하이버네이트 어노테이션으로 ORM 매핑*

이제 자바 POJO 엔티티 클래스를 설계하고 엔티티 클래스와 기반 관계형 데이터 구조 사이의 매핑을 설계합니다.

매핑 방법은 두 가지가 있습니다.
- 객체 모델을 설계하고 설계된 객체 모델을 기반으로 데이터베이스 스크립트를 생성.
- 기존 데이터 모델을 기반으로 해당 모델에 맞는 캐핑을 가진 POJO를 설계.

두 번째 방법으로 진행합니다.

### *하이버네이트 어노테이션으로 ORM 매핑 - 단순 매핑*

클래스는 가수(Singer), 앨범(Album), 악기(Instrument) 세 클래스를 사용합니다.  
클래스의 단순 애트리뷰트를 매핑하는 것부터 시작합니다.

```
@Entity
@Table(name = "singer")
public class Singer implements Serializable {

	private Long id;
	private String firstName;
	private String lastName;
	private Date birthDate;
	private int version;

	public void setId(Long id) {
		this.id = id;
	}

	@Id
	@GeneratedValue(strategy = IDENTITY)
	@Column(name = "ID")
	public Long getId() {
		return this.id;
	}

	@Version
	@Column(name = "VERSION")
	public int getVersion() {
		return version;
	}

	@Column(name = "FIRST_NAME")
	public String getFirstName() {
		return this.firstName;
	}

	@Column(name = "LAST_NAME")
	public String getLastName() {
		return this.lastName;
	}

	@Temporal(TemporalType.DATE)
	@Column(name = "BIRTH_DATE")
	public Date getBirthDate() {
		return birthDate;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	public void setBirthDate(Date birthDate) {
		this.birthDate = birthDate;
	}

	public void setVersion(int version) {
		this.version = version;
	}

	public void setInstruments(Set<Instrument> instruments) {
		this.instruments = instruments;
	}

	public boolean addInstrument(Instrument instrument) {
		return getInstruments().add(instrument);
	}

	public String toString() {
		return "Singer - Id: " + id + ", First name: " + firstName
				+ ", Last name: " + lastName + ", Birthday: " + birthDate;
	}
}
```

- @Entity: 데이터베이스의 테이블과 일대일로 매칭되는 객체 단위이며 Entity 객체의 인스턴스 하나가 테이블에서 하나의 레코드값을 의미한다. 그래서 객체의 인스턴스를 구분하기 위한 유일한 키 값을 가지는데, 이것은 테이블 상의 Primary Key와 동일한 의미를 가진다. 그리고 이것을 @Id 어노테이션으로 표기한다.

- @Table: 엔티티 클래스가 매핑되어야 할 데이터베이스 테이블 이름을 정의한다. name 속성을 이용해서 테이블 이름을 정의한다. 만약 테이블 이름을 정의하지 않는다면 엔티티 클래스의 이름 그대로 카멜 케이스 형식의 이름으로 테이블이 생성된다.
- @Column: 각 매핑 애트리뷰트에는 컬럼 이름을 지정한다. 
- 날짜를 표시하는 birthDate 애트리뷰트에는 Temporal.DATE 값을 인수로 받는 @Temporal 어노테이션을 사용했는데, 이는 자바 Date 타입(jata.util.Date)을 SQL Date 타입(java.sql.Date)으로 매핑한다는 의미이다. 이 설정을 통해 어플리케이션에서는 java.util.Date로 Singer 객체의 birthDate 애트리뷰트에 접근할 수 있다.
- @GeneratedValue: id값 생성 방법을 하이버네이트에 알려준다. 전략은 네 가지가 있다.
    - IDENTITY: primary key 생성을 DB에 위임하는 방식. id값을 따로 할당하지 않아도 DB가 자동으로 AUTO_INCREMENT 해서 primary key를 생성한다. 새로운 레코드가 생성 될때마다 마지막 PK 값에서 자동으로 +1을 해주는 방식.
    - SEQUENCE: DB의 Sequence Object를 사용해서 DB가 자동으로 primary key를 생성한다. 사용 시 @SequenceGenerator 어노테이션이 필요하다.
    - TABLE: DB에 키 생성 전용 테이블을 하나 생성하고, 이를 사용해서 primary key를 생성한다.
    - AUTO: 기본 설정 값. 각 DB에 따라 primary key를 자동으로 생성한다.
- @Version: 애트리뷰트 제어 수단으로 사용하는 낙관적 잠금(Optimistic Locking) 매커니즘을 사용한다는 의미. 하이버네이트가 레코드를 수정할 때마다 엔티티 인스턴스의 version과 DB 레코드의 version을 비교해서 만약 값이 같으면 수정이 발생하지 않았다는 뜻이므로 하이버네이트가 데이터를 수정해서 version 레코드의 값을 증가시킨다. 반면 값이 같지 않으면 누군가에 의해 DB 레코드가 수정되었다는 뜻이므로 예외를 발생시킨다.

Album 객체는 album 테이블에 매핑되며, singer 클래스와 일대일 관계를 가집니다.

```
@Entity
@Table(name = "album")
public class Album implements Serializable {

	private Long id;
	private String title;
	private Date releaseDate;
	private int version;

	public void setId(Long id) {
		this.id = id;
	}

	@Id
	@GeneratedValue(strategy = IDENTITY)
	@Column(name = "ID")
	public Long getId() {
		return this.id;
	}

	@Version
	@Column(name = "VERSION")
	public int getVersion() {
		return version;
	}

	@Column
	public String getTitle() {
		return this.title;
	}

	@Temporal(TemporalType.DATE)
	@Column(name = "RELEASE_DATE")
	public Date getReleaseDate() {
		return this.releaseDate;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public void setSinger(Singer singer) {
		this.singer = singer;
	}

	public void setReleaseDate(Date releaseDate) {
		this.releaseDate = releaseDate;
	}

	public void setVersion(int version) {
		this.version = version;
	}

	@Override
	public String toString() {
		return "Album - Id: " + id + ", Singer id: " + singer.getId()
				+ ", Title: " + title + ", Release Date: " + releaseDate;
	}
}
```

### *하이버네이트 어노테이션으로 ORM 매핑 - 일대다 매핑*

Singer는 Album이 있을 수도 있고, 있다면 여러개가 있을 수 있습니다. 그러므로 Singer-Album 테이블은 일대다(One-to-many) 관계를 가집니다. 하이버네이트는 일대다를 포함한 여러 종류의 관계를 표현할 수 있습니다.

단순 매핑으로 표현한 Singer, Album 클래스를 일대다 관계를 표현할 수 있도록 다시 작성해봅니다.

Singer-Album 테이블은 OneToMany 관계입니다.  
Album-Singer 테이블은 ManyToOne 관계입니다.  
Singer-Instrument 테이블은 ManyToMany 관계입니다.

```
@Entity
@Table(name = "singer")
public class Singer implements Serializable {

	private Long id;
	private String firstName;
	private String lastName;
	private Date birthDate;
	private int version;
	private Set<Album> albums = new HashSet<>();
	private Set<Instrument> instruments = new HashSet<>();

	public void setId(Long id) {
		this.id = id;
	}

	@Id
	@GeneratedValue(strategy = IDENTITY)
	@Column(name = "ID")
	public Long getId() {
		return this.id;
	}

	@Version
	@Column(name = "VERSION")
	public int getVersion() {
		return version;
	}

	@Column(name = "FIRST_NAME")
	public String getFirstName() {
		return this.firstName;
	}

	@Column(name = "LAST_NAME")
	public String getLastName() {
		return this.lastName;
	}

	@Temporal(TemporalType.DATE)
	@Column(name = "BIRTH_DATE")
	public Date getBirthDate() {
		return birthDate;
	}

	@OneToMany(mappedBy = "singer", cascade=CascadeType.ALL,
			orphanRemoval=true)
	public Set<Album> getAlbums() {
		return albums;
	}


	@ManyToMany
	@JoinTable(name = "singer_instrument",
			joinColumns = @JoinColumn(name = "SINGER_ID"),
			inverseJoinColumns = @JoinColumn(name = "INSTRUMENT_ID"))
	public Set<Instrument> getInstruments() {
		return instruments;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	public boolean addAlbum(Album album) {
		album.setSinger(this);
		return getAlbums().add(album);
	}

	public void removeAlbum(Album album) {
		getAlbums().remove(album);
	}

	public void setAlbums(Set<Album> albums) {
		this.albums = albums;
	}

	public void setBirthDate(Date birthDate) {
		this.birthDate = birthDate;
	}

	public void setVersion(int version) {
		this.version = version;
	}

	public void setInstruments(Set<Instrument> instruments) {
		this.instruments = instruments;
	}

	public boolean addInstrument(Instrument instrument) {
		return getInstruments().add(instrument);
	}

	public String toString() {
		return "Singer - Id: " + id + ", First name: " + firstName
				+ ", Last name: " + lastName + ", Birthday: " + birthDate;
	}
}
```

- @OneToMany(mappedBy = "singer", cascade=CascadeType.ALL, orphanRemoval=true): 
    - Singer 엔티티 입장에서 Album 엔티티를 바라볼 때 OneToMany 관계이다. 그리고 mappedBy 속성은 연관관계의 주인이 누구인지를 설정한다. 코드에서는 Singer 테이블이 Singer-Album 연관관계의 주인이라고 설정했다. 이렇게 되면 singer를 가지고 있는 Album 테이블이 FK_ALBUM_SINGER의 주인이 되는 것이다. 
	- cascade 속성은 수정 작업이 수정 테이블부터 관련 자식 테이블까지 모두 전이되는지를 나타낸다. 
	- orphanRemoval 속성은 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제되는지의 여부를 체크한다. 

- @ManyToMany: Singer-Instrument 테이블의 관계는 다대다 관계이다. 
- @JoinTable(name = "singer_instrument",joinColumns = @JoinColumn(name = "SINGER_ID"),inverseJoinColumns = @JoinColumn(name = "INSTRUMENT_ID")): 조인 테이블 관련 내용을 정의한다.

다음은 Album 클래스 코드이다.

```
@Entity
@Table(name = "album")
public class Album implements Serializable {

	private Long id;
	private String title;
	private Date releaseDate;
	private int version;

	private Singer singer;

	public void setId(Long id) {
		this.id = id;
	}

	@Id
	@GeneratedValue(strategy = IDENTITY)
	@Column(name = "ID")
	public Long getId() {
		return this.id;
	}

	@Version
	@Column(name = "VERSION")
	public int getVersion() {
		return version;
	}

	@ManyToOne
	@JoinColumn(name = "SINGER_ID")
	public Singer getSinger() {
		return this.singer;
	}

	@Column
	public String getTitle() {
		return this.title;
	}

	@Temporal(TemporalType.DATE)
	@Column(name = "RELEASE_DATE")
	public Date getReleaseDate() {
		return this.releaseDate;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public void setSinger(Singer singer) {
		this.singer = singer;
	}

	public void setReleaseDate(Date releaseDate) {
		this.releaseDate = releaseDate;
	}

	public void setVersion(int version) {
		this.version = version;
	}

	@Override
	public String toString() {
		return "Album - Id: " + id + ", Singer id: " + singer.getId()
				+ ", Title: " + title + ", Release Date: " + releaseDate;
	}
}
```

- @ManyToOne: Album 엔티티의 입장에서 Singer 엔티티와의 관계는 ManyToOne이다.
- @JoinColumn(name = "SINGER_ID"): 테이블 조인 관련 설정.

Instrument 클래스 코드이다.

```
@Entity
@Table(name = "instrument")
public class Instrument implements Serializable {
	private String instrumentId;
	private Set<Singer> singers = new HashSet<>();

	@Id
	@Column(name = "INSTRUMENT_ID")
	public String getInstrumentId() {
		return this.instrumentId;
	}

	@ManyToMany
	@JoinTable(name = "singer_instrument",
			joinColumns = @JoinColumn(name = "INSTRUMENT_ID"),
			inverseJoinColumns = @JoinColumn(name = "SINGER_ID"))
	public Set<Singer> getSingers() {
		return this.singers;
	}

	public void setSingers(Set<Singer> singers) {
		this.singers = singers;
	}

	public void setInstrumentId(String instrumentId) {
		this.instrumentId = instrumentId;
	}

	@Override
	public String toString() {
		return "Instrument :" + getInstrumentId();
	}
}
```

## 참고

- https://hibernate.org/
- https://rutgo-letsgo.tistory.com/306